# CRA CP2 Phase 2 evaluation environment

This repository contains the evaluation environment for testing the
CRA CP2 Phase 2 systems (bintools and OS synthesizer) using the MIT
Lincoln Labs test harness.

The environment is set up using Docker.
The Harvard-PRINCESS material (the system-under-test or SUT) packages
as one Docker container; the LL test harness as another.

![CP2 Evaluation service diagram](cp2-eval-service-diagram.png?raw=true "Title"))

## Interaction protocol

The interaction between the SUT and the test harness is defined by the
[CP2 description document]
https://github.mit.edu/brass/cra-princess/blob/master/Phase2/CP%20Descriptions/CP2/CRA-CP2-v12.docx
(another copy is included in this directory)

Any discrepancies between this code and that document are
presumptively bugs in this code.

### Interpretation of parameters

The `InitialParams` response to READY contains four fields:
1. `Baseline` -- the test type
2. `Target` -- the test selection seed
3. `TargetType` -- see next paragraph
4. `Contents` -- see next paragraph

The `TargetType` field selects whether to test the toolchain (if
`Cprog`) or the synthesis (if `DSLprog`).
The `Contents` field contains a string, which is interpreted as either
the number of the test file to use (if no more than ten characters
that convert to an integer) or as the contents of the program to test
on. (This allows supporting both the RR2+ and RR1.5 versions of the
interaction protocol.) The test program is, for `Cprog`, a C program
generated by Csmith, and for `DSLprog`, an OS code snippet.

The OS code snippets may be found in the
directory cp2/snippets. These are numbered starting at 0; any number
for which the corresponding files exist in cp2/snippets can be passed
as the value in the `Contents` field.

An example Csmith test corpus is provided in the directory
cp2/corpus. The corpus generator (a Docker container that runs
csmith and filters out bad tests based on agreed-upon criteria) is
provided in the directory csmith/.
The number in the `Contents` field chooses one of the C programs in
the corpus by number. Thus, any number from 0 up to the corpus size
may be used.
One can use the corpus generator to generate alternate corpora of
arbitrary size.
(To use a different corpus, it is sufficient to move the old
cp2/corpus directory out of the way, move a new one in, and rebuild
the Docker container.)

If sending a `DSLprog` snippet directly in the value of the `Contents`
field the first two lines will be treated as the specification
(comparable to the spec*.ale files in the cp2/snippets directory) and
the rest as the handwritten native version for the selected
architecture (comparable to the native*.prog files in the cp2/snippets
directory).

The `Baseline` value should be one of the strings `A`, `A*`, `B`, or
`Challenge`.
Baseline A* applies only to the `Cprog` case, where Baseline B is
not meaningful.
(So for `Cprog`, `Baseline` should be `A`, `A*`, or `Challenge`, and
for `DSLprog`, it should be `A`, `B`, or `Challenge`.)

The `Target` value is a 64-bit unsigned integer and is used to select
further test parameters beyond those above.

For `Cprog` the bottom four bits are used to select the target
architecture, and the rest are unused.

This allows up to 16 architectures:

| `Target` mod 16 | Architecture                  |
| ---            | ---                           |
| 0              | Specifically (always) invalid |
| 1              | arm (32-bit ARM EABI)         |
| 2              | sparc64 (64-bit SPARC)        |
| 3-12           | Reserved, behavior not specified |
| 13             | Unnamed architecture that is not supported by bintools |
| 14             | Unnamed architecture where the bintools adaptation fails |
| 15             | Unnamed architecture with no cross-compiler |

The purpose of architectures 0 and 13-15 was to allow testing failure
paths in the SUT/harness interaction for RR1.5.
They have been left in place for testing purposes.

For `DSLprog` the `Target` value is divided into an architecture field, a reserved field for future use, and a perturbation field.
(note that the architecture field does NOT use the same numbering system or specify the same set of architectures as the same field when `Cprog` is specified)

For `DSLprog` the bottom three bits are used to select the target
architecture, the bottom fourth bit is reserved, and the remainder of the seed is used to specify an architectural perturbation.

We allow specification of two named architectures, ARMv7-A and x86-64. In each case, we describe only subsets of each named architecture.
We do this to ensure that evaluation is tractrable. That is, our machine descriptions are both of
simplified machines that model the two named architectures.

that contain subsets of instructions and machine state from the real architectures.
'Target' bitfields:

| Perturbation | Reserved | Architecture |
| ---           | ---       | ---          |
| 63 ... 4 | 3 | 2 ... 0 |

| Architecture Field | Named Architecture | Reference Manual |
| ---            | ---        | --- |
| 0              | ARMV7-A | https://www.scss.tcd.ie/~waldroj/3d1/arm_arm.pdf
| 1              | x86-64 | http://math-atlas.sourceforge.net/devel/assembly/ppc_isa.pdf
| 2-15           | Reserved, behavior not specified |

For each named architecture, we provide four "perturbed" machine descriptions. In particular,
machine description perturbation K is a model of the named architecture with exactly K registers,
with the exact registers chosen by hand by Harvard based on how the register is used by the
named architecture. Example: In ARMv7-a, the LR (link register) register, aliased to general
purpose register R14 provides strictly more functionality than the purely general purpose register R6.
Hence, our ARM machine descriptions, except for the machine with zero registers, retain LR/R14.

The instructions defined in perturbations smaller than 4 are the maximal subset definable with
the registers that are defined in the perturbed machine.

| Perturbation | Meaning |
| ---          | ---     |
| 0 | Perturbed machine description with zero registers (guaranteed to fail synthesis) |
| 1 | Perturbed machine description with one register      |
| 2 | Perturbed machine description with two registers     |
| 3 | Perturbed machine description with three registers   |
| 4 | Perturbed machine description with four registers    |
| 5 - ... | Reserved, behavior not specified.

## Docker container

NOTE: currently the release process may cause execute permissions to
be dropped. The docker*.sh scripts in both the cp2/ and csmith/
subdirectories should be executable. If they are not, run "sh
./fixperms.sh" at the top of the tree; this will restore execute
permissions on those and in some other necessary places.

The material in the cp2/ subdirectory creates a single Docker
container (named by default "harvard-princess/sut") that contains all
the evaluation material. It can be built (from that directory) with
```
docker build -t harvard-princess/sut .
```
or by using the script "dockerbuild.sh", which does exactly this.

To run it, pass the command
```
python3 main.py --host harness-host --port harness-port
```
to docker-run, like this:
```
docker run --rm harvard-princess/sut python3 main.py --host harness-host --port harness-port
```
or use the script "dockerrun.sh" which accepts the host and port as a
single argument of the form `harness-host[:harness-port]`.

For `harness-host` pass the hostname the SUT should use to reach the
test harness. The default is localhost, which is almost certainly not
useful. (But it is unclear what other default to use.)

For `harness-port` pass the port number. The default is 9870, which is
what the harness code uses by default and should not ordinarily need to be
changed.

The image can also be integrated into a docker-compose system or other
larger Docker construct.
We use the following docker-compose.yml fragment for this:
```
version: '2'
services:
  sut:
    image: harvard-princess/sut:latest
    build:
      context: cp2
      dockerfile: Dockerfile
    depends_on:
      - harness
    environment: # is this necessary?
      - no_proxy=sut
      - NO_PROXY=sut
    entrypoint:
      - python3
      - main.py
      - --host
      - harness
    ports:
      - "5555:5555"
```
which assumes the harness is defined as another service called "harness".

