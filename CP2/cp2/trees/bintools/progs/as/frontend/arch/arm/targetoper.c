/* Automatically generated; do not edit */

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include "common.h"

#include "expr.h"
#include "eparse.h"
#include "token.h"
#include "targetoper.h"

static bool tagrulematch_0(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   const char * s;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 1U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_STRING))return false;
   s = dostrdup((l__t -> t_value));
   if (!(l__num == 1U))return false;
   if (!true)return false;
   oper->is_qstring = true;
   oper->val_qstring = s;
   return true;
}
static bool tagrulematch_1(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t r;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 1U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   r = l__ul;
   if (!(l__num == 1U))return false;
   if (!true)return false;
   oper->is_reg = true;
   oper->val_reg = r;
   return true;
}
static bool tagrulematch_2(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t r;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 1U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   r = l__ul;
   if (!(l__num == 1U))return false;
   if (!true)return false;
   oper->is_signedreg = true;
   (oper -> val_signedreg).m0 = 1U /* PLUS */;
   (oper -> val_signedreg).m1 = r;
   return true;
}
static bool tagrulematch_3(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t r;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 2U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   r = l__ul;
   if (!(l__num == 2U))return false;
   if (!true)return false;
   oper->is_signedreg = true;
   (oper -> val_signedreg).m0 = 1U /* PLUS */;
   (oper -> val_signedreg).m1 = r;
   return true;
}
static bool tagrulematch_4(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t r;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 2U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   r = l__ul;
   if (!(l__num == 2U))return false;
   if (!true)return false;
   oper->is_signedreg = true;
   (oper -> val_signedreg).m0 = 0U /* MINUS */;
   (oper -> val_signedreg).m1 = r;
   return true;
}
static bool tagrulematch_5(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t r;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 1U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   r = l__ul;
   if (!(l__num == 1U))return false;
   if (!true)return false;
   oper->is_bangreg = true;
   (oper -> val_bangreg).m0 = r;
   (oper -> val_bangreg).m1 = 0U /* LSNORMAL_LSOFFSET */;
   return true;
}
static bool tagrulematch_6(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t r;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 2U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   r = l__ul;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 2U))return false;
   if (!true)return false;
   oper->is_bangreg = true;
   (oper -> val_bangreg).m0 = r;
   (oper -> val_bangreg).m1 = 1U /* LSUNPRIV_LSPREINDEX */;
   return true;
}
static bool tagrulematch_7(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 2U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   if (!(l__num == 2U))return false;
   if (!!(4294967295ULL < n))return false;
   oper->is_imm = true;
   oper->val_imm =(uint32_t)n;
   return true;
}
static bool tagrulematch_8(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 3U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   if (!(l__num == 3U))return false;
   if (!!(4294967295ULL < n))return false;
   oper->is_imm = true;
   oper->val_imm =(uint32_t)n;
   return true;
}
static bool tagrulematch_9(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 3U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   if (!(l__num == 3U))return false;
   if (!!(4294967295ULL <(n - 1ULL)))return false;
   oper->is_imm = true;
   oper->val_imm =(uint32_t)-n;
   return true;
}
static bool tagrulematch_10(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 1U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   if (!(l__num == 1U))return false;
   if (!!(4294967295ULL < n))return false;
   oper->is_imm = true;
   oper->val_imm =(uint32_t)n;
   return true;
}
static bool tagrulematch_11(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 2U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   if (!(l__num == 2U))return false;
   if (!!(4294967295ULL < n))return false;
   oper->is_imm = true;
   oper->val_imm =(uint32_t)n;
   return true;
}
static bool tagrulematch_12(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 2U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   if (!(l__num == 2U))return false;
   if (!!(4294967295ULL <(n - 1ULL)))return false;
   oper->is_imm = true;
   oper->val_imm =(uint32_t)-n;
   return true;
}
static bool tagrulematch_13(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 2U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   if (!(l__num == 2U))return false;
   if (!!(255ULL < n))return false;
   oper->is_signedimm8 = true;
   (oper -> val_signedimm8).m0 = 1U /* PLUS */;
   (oper -> val_signedimm8).m1 =(uint8_t)n;
   return true;
}
static bool tagrulematch_14(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 3U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   if (!(l__num == 3U))return false;
   if (!!(255ULL < n))return false;
   oper->is_signedimm8 = true;
   (oper -> val_signedimm8).m0 = 1U /* PLUS */;
   (oper -> val_signedimm8).m1 =(uint8_t)n;
   return true;
}
static bool tagrulematch_15(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 3U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   if (!(l__num == 3U))return false;
   if (!!(255ULL < n))return false;
   oper->is_signedimm8 = true;
   (oper -> val_signedimm8).m0 = 0U /* MINUS */;
   (oper -> val_signedimm8).m1 =(uint8_t)n;
   return true;
}
static bool tagrulematch_16(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 2U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   if (!(l__num == 2U))return false;
   if (!!(4095ULL < n))return false;
   oper->is_signedimm12 = true;
   (oper -> val_signedimm12).m0 = 1U /* PLUS */;
   (oper -> val_signedimm12).m1 =(uint16_t)n;
   return true;
}
static bool tagrulematch_17(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 3U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   if (!(l__num == 3U))return false;
   if (!!(4095ULL < n))return false;
   oper->is_signedimm12 = true;
   (oper -> val_signedimm12).m0 = 1U /* PLUS */;
   (oper -> val_signedimm12).m1 =(uint16_t)n;
   return true;
}
static bool tagrulematch_18(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 3U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   if (!(l__num == 3U))return false;
   if (!!(4095ULL < n))return false;
   oper->is_signedimm12 = true;
   (oper -> val_signedimm12).m0 = 0U /* MINUS */;
   (oper -> val_signedimm12).m1 =(uint16_t)n;
   return true;
}
static bool tagrulematch_19(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t s;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 3U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_SHIFTCODE)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   s = l__ul;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   if (!(l__num == 3U))return false;
   if (!!(31ULL < n))return false;
   oper->is_ishift = true;
   (oper -> val_ishift).m0 = s;
   (oper -> val_ishift).m1 =(uint8_t)n;
   return true;
}
static bool tagrulematch_20(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 1U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_IDENT))return false;
   if (!!strcmp((l__t -> t_value), "rrx"))return false;
   if (!(l__num == 1U))return false;
   if (!true)return false;
   oper->is_ishift = true;
   (oper -> val_ishift).m0 = 3U /* ROR */;
   (oper -> val_ishift).m1 = 0U;
   return true;
}
static bool tagrulematch_21(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t s;
   uint8_t r;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 2U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_SHIFTCODE)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   s = l__ul;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   r = l__ul;
   if (!(l__num == 2U))return false;
   if (!true)return false;
   oper->is_rshift = true;
   (oper -> val_rshift).m0 = s;
   (oper -> val_rshift).m1 = r;
   return true;
}
static bool tagrulematch_22(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 3U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 3U))return false;
   if (!true)return false;
   oper->is_am2imm = true;
   (oper -> val_am2imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2imm).m1 = 1U /* PLUS */;
   (oper -> val_am2imm).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am2imm).m3 = rn;
   (oper -> val_am2imm).m4 = 0U;
   return true;
}
static bool tagrulematch_23(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 6U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 6U))return false;
   if (!!(4095ULL < n))return false;
   oper->is_am2imm = true;
   (oper -> val_am2imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2imm).m1 = 1U /* PLUS */;
   (oper -> val_am2imm).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am2imm).m3 = rn;
   (oper -> val_am2imm).m4 =(uint16_t)n;
   return true;
}
static bool tagrulematch_24(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 7U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 7U))return false;
   if (!!(4095ULL < n))return false;
   oper->is_am2imm = true;
   (oper -> val_am2imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2imm).m1 = 1U /* PLUS */;
   (oper -> val_am2imm).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am2imm).m3 = rn;
   (oper -> val_am2imm).m4 =(uint16_t)n;
   return true;
}
static bool tagrulematch_25(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 7U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 7U))return false;
   if (!!(4095ULL < n))return false;
   oper->is_am2imm = true;
   (oper -> val_am2imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2imm).m1 = 0U /* MINUS */;
   (oper -> val_am2imm).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am2imm).m3 = rn;
   (oper -> val_am2imm).m4 =(uint16_t)n;
   return true;
}
static bool tagrulematch_26(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 8U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 8U))return false;
   if (!!(4095ULL < n))return false;
   oper->is_am2imm = true;
   (oper -> val_am2imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2imm).m1 = 1U /* PLUS */;
   (oper -> val_am2imm).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am2imm).m3 = rn;
   (oper -> val_am2imm).m4 =(uint16_t)n;
   return true;
}
static bool tagrulematch_27(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 7U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 7U))return false;
   if (!!(4095ULL < n))return false;
   oper->is_am2imm = true;
   (oper -> val_am2imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2imm).m1 = 1U /* PLUS */;
   (oper -> val_am2imm).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am2imm).m3 = rn;
   (oper -> val_am2imm).m4 =(uint16_t)n;
   return true;
}
static bool tagrulematch_28(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 8U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 8U))return false;
   if (!!(4095ULL < n))return false;
   oper->is_am2imm = true;
   (oper -> val_am2imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2imm).m1 = 0U /* MINUS */;
   (oper -> val_am2imm).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am2imm).m3 = rn;
   (oper -> val_am2imm).m4 =(uint16_t)n;
   return true;
}
static bool tagrulematch_29(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 5U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 5U))return false;
   if (!true)return false;
   oper->is_am2reg = true;
   (oper -> val_am2reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2reg).m1 = 1U /* PLUS */;
   (oper -> val_am2reg).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am2reg).m3 = rn;
   (oper -> val_am2reg).m4 = rm;
   (oper -> val_am2reg).m5 = 0U /* LSL */;
   (oper -> val_am2reg).m6 =(uint8_t)0ULL;
   return true;
}
static bool tagrulematch_30(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 6U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 6U))return false;
   if (!true)return false;
   oper->is_am2reg = true;
   (oper -> val_am2reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2reg).m1 = 1U /* PLUS */;
   (oper -> val_am2reg).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am2reg).m3 = rn;
   (oper -> val_am2reg).m4 = rm;
   (oper -> val_am2reg).m5 = 0U /* LSL */;
   (oper -> val_am2reg).m6 =(uint8_t)0ULL;
   return true;
}
static bool tagrulematch_31(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 6U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 6U))return false;
   if (!true)return false;
   oper->is_am2reg = true;
   (oper -> val_am2reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2reg).m1 = 0U /* MINUS */;
   (oper -> val_am2reg).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am2reg).m3 = rn;
   (oper -> val_am2reg).m4 = rm;
   (oper -> val_am2reg).m5 = 0U /* LSL */;
   (oper -> val_am2reg).m6 =(uint8_t)0ULL;
   return true;
}
static bool tagrulematch_32(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   uint8_t s;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 9U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_SHIFTCODE)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   s = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 9U))return false;
   if (!!(31ULL < n))return false;
   oper->is_am2reg = true;
   (oper -> val_am2reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2reg).m1 = 1U /* PLUS */;
   (oper -> val_am2reg).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am2reg).m3 = rn;
   (oper -> val_am2reg).m4 = rm;
   (oper -> val_am2reg).m5 = s;
   (oper -> val_am2reg).m6 =(uint8_t)n;
   return true;
}
static bool tagrulematch_33(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   uint8_t s;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 10U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 6U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_SHIFTCODE)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   s = l__ul;
   l__t = tokenarray_get(toks, 7U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 9U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 10U))return false;
   if (!!(31ULL < n))return false;
   oper->is_am2reg = true;
   (oper -> val_am2reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2reg).m1 = 1U /* PLUS */;
   (oper -> val_am2reg).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am2reg).m3 = rn;
   (oper -> val_am2reg).m4 = rm;
   (oper -> val_am2reg).m5 = s;
   (oper -> val_am2reg).m6 =(uint8_t)n;
   return true;
}
static bool tagrulematch_34(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   uint8_t s;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 10U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 6U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_SHIFTCODE)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   s = l__ul;
   l__t = tokenarray_get(toks, 7U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 9U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 10U))return false;
   if (!!(31ULL < n))return false;
   oper->is_am2reg = true;
   (oper -> val_am2reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2reg).m1 = 0U /* MINUS */;
   (oper -> val_am2reg).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am2reg).m3 = rn;
   (oper -> val_am2reg).m4 = rm;
   (oper -> val_am2reg).m5 = s;
   (oper -> val_am2reg).m6 =(uint8_t)n;
   return true;
}
static bool tagrulematch_35(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 6U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 6U))return false;
   if (!true)return false;
   oper->is_am2reg = true;
   (oper -> val_am2reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2reg).m1 = 1U /* PLUS */;
   (oper -> val_am2reg).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am2reg).m3 = rn;
   (oper -> val_am2reg).m4 = rm;
   (oper -> val_am2reg).m5 = 0U /* LSL */;
   (oper -> val_am2reg).m6 =(uint8_t)0ULL;
   return true;
}
static bool tagrulematch_36(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 7U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 7U))return false;
   if (!true)return false;
   oper->is_am2reg = true;
   (oper -> val_am2reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2reg).m1 = 1U /* PLUS */;
   (oper -> val_am2reg).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am2reg).m3 = rn;
   (oper -> val_am2reg).m4 = rm;
   (oper -> val_am2reg).m5 = 0U /* LSL */;
   (oper -> val_am2reg).m6 =(uint8_t)0ULL;
   return true;
}
static bool tagrulematch_37(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 7U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 7U))return false;
   if (!true)return false;
   oper->is_am2reg = true;
   (oper -> val_am2reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2reg).m1 = 0U /* MINUS */;
   (oper -> val_am2reg).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am2reg).m3 = rn;
   (oper -> val_am2reg).m4 = rm;
   (oper -> val_am2reg).m5 = 0U /* LSL */;
   (oper -> val_am2reg).m6 =(uint8_t)0ULL;
   return true;
}
static bool tagrulematch_38(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   uint8_t s;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 10U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_SHIFTCODE)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   s = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 10U))return false;
   if (!!(31ULL < n))return false;
   oper->is_am2reg = true;
   (oper -> val_am2reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2reg).m1 = 1U /* PLUS */;
   (oper -> val_am2reg).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am2reg).m3 = rn;
   (oper -> val_am2reg).m4 = rm;
   (oper -> val_am2reg).m5 = s;
   (oper -> val_am2reg).m6 =(uint8_t)n;
   return true;
}
static bool tagrulematch_39(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   uint8_t s;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 11U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 6U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_SHIFTCODE)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   s = l__ul;
   l__t = tokenarray_get(toks, 7U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 9U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 11U))return false;
   if (!!(31ULL < n))return false;
   oper->is_am2reg = true;
   (oper -> val_am2reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2reg).m1 = 1U /* PLUS */;
   (oper -> val_am2reg).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am2reg).m3 = rn;
   (oper -> val_am2reg).m4 = rm;
   (oper -> val_am2reg).m5 = s;
   (oper -> val_am2reg).m6 =(uint8_t)n;
   return true;
}
static bool tagrulematch_40(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   uint8_t s;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 11U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 6U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_SHIFTCODE)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   s = l__ul;
   l__t = tokenarray_get(toks, 7U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 9U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 11U))return false;
   if (!!(31ULL < n))return false;
   oper->is_am2reg = true;
   (oper -> val_am2reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am2reg).m1 = 0U /* MINUS */;
   (oper -> val_am2reg).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am2reg).m3 = rn;
   (oper -> val_am2reg).m4 = rm;
   (oper -> val_am2reg).m5 = s;
   (oper -> val_am2reg).m6 =(uint8_t)n;
   return true;
}
static bool tagrulematch_41(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 3U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 3U))return false;
   if (!true)return false;
   oper->is_bracketreg = true;
   oper->val_bracketreg = rn;
   return true;
}
static bool tagrulematch_42(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 3U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 3U))return false;
   if (!true)return false;
   oper->is_am3imm = true;
   (oper -> val_am3imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3imm).m1 = 1U /* PLUS */;
   (oper -> val_am3imm).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am3imm).m3 = rn;
   (oper -> val_am3imm).m4 = 0U;
   return true;
}
static bool tagrulematch_43(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 6U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 6U))return false;
   if (!!(255ULL < n))return false;
   oper->is_am3imm = true;
   (oper -> val_am3imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3imm).m1 = 1U /* PLUS */;
   (oper -> val_am3imm).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am3imm).m3 = rn;
   (oper -> val_am3imm).m4 =(uint8_t)n;
   return true;
}
static bool tagrulematch_44(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 7U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 7U))return false;
   if (!!(255ULL < n))return false;
   oper->is_am3imm = true;
   (oper -> val_am3imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3imm).m1 = 1U /* PLUS */;
   (oper -> val_am3imm).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am3imm).m3 = rn;
   (oper -> val_am3imm).m4 =(uint8_t)n;
   return true;
}
static bool tagrulematch_45(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 7U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 7U))return false;
   if (!!(255ULL < n))return false;
   oper->is_am3imm = true;
   (oper -> val_am3imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3imm).m1 = 0U /* MINUS */;
   (oper -> val_am3imm).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am3imm).m3 = rn;
   (oper -> val_am3imm).m4 =(uint8_t)n;
   return true;
}
static bool tagrulematch_46(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 5U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 5U))return false;
   if (!true)return false;
   oper->is_am3reg = true;
   (oper -> val_am3reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3reg).m1 = 1U /* PLUS */;
   (oper -> val_am3reg).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am3reg).m3 = rn;
   (oper -> val_am3reg).m4 = rm;
   return true;
}
static bool tagrulematch_47(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 6U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 6U))return false;
   if (!true)return false;
   oper->is_am3reg = true;
   (oper -> val_am3reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3reg).m1 = 1U /* PLUS */;
   (oper -> val_am3reg).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am3reg).m3 = rn;
   (oper -> val_am3reg).m4 = rm;
   return true;
}
static bool tagrulematch_48(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 6U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   if (!(l__num == 6U))return false;
   if (!true)return false;
   oper->is_am3reg = true;
   (oper -> val_am3reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3reg).m1 = 0U /* MINUS */;
   (oper -> val_am3reg).m2 = 0U /* LSNORMAL_LSOFFSET */;
   (oper -> val_am3reg).m3 = rn;
   (oper -> val_am3reg).m4 = rm;
   return true;
}
static bool tagrulematch_49(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 4U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 4U))return false;
   if (!true)return false;
   oper->is_am3imm = true;
   (oper -> val_am3imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3imm).m1 = 1U /* PLUS */;
   (oper -> val_am3imm).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am3imm).m3 = rn;
   (oper -> val_am3imm).m4 = 0U;
   return true;
}
static bool tagrulematch_50(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 7U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 7U))return false;
   if (!!(255ULL < n))return false;
   oper->is_am3imm = true;
   (oper -> val_am3imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3imm).m1 = 1U /* PLUS */;
   (oper -> val_am3imm).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am3imm).m3 = rn;
   (oper -> val_am3imm).m4 =(uint8_t)n;
   return true;
}
static bool tagrulematch_51(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 8U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 8U))return false;
   if (!!(255ULL < n))return false;
   oper->is_am3imm = true;
   (oper -> val_am3imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3imm).m1 = 1U /* PLUS */;
   (oper -> val_am3imm).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am3imm).m3 = rn;
   (oper -> val_am3imm).m4 =(uint8_t)n;
   return true;
}
static bool tagrulematch_52(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint64_t n;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 8U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_HASH))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   n = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 8U))return false;
   if (!!(255ULL < n))return false;
   oper->is_am3imm = true;
   (oper -> val_am3imm).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3imm).m1 = 0U /* MINUS */;
   (oper -> val_am3imm).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am3imm).m3 = rn;
   (oper -> val_am3imm).m4 =(uint8_t)n;
   return true;
}
static bool tagrulematch_53(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 6U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 6U))return false;
   if (!true)return false;
   oper->is_am3reg = true;
   (oper -> val_am3reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3reg).m1 = 1U /* PLUS */;
   (oper -> val_am3reg).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am3reg).m3 = rn;
   (oper -> val_am3reg).m4 = rm;
   return true;
}
static bool tagrulematch_54(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 7U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_PLUS))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 7U))return false;
   if (!true)return false;
   oper->is_am3reg = true;
   (oper -> val_am3reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3reg).m1 = 1U /* PLUS */;
   (oper -> val_am3reg).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am3reg).m3 = rn;
   (oper -> val_am3reg).m4 = rm;
   return true;
}
static bool tagrulematch_55(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t rn;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 7U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACK))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 4U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_RBRACK))return false;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_BANG))return false;
   if (!(l__num == 7U))return false;
   if (!true)return false;
   oper->is_am3reg = true;
   (oper -> val_am3reg).m0 = 1U /* NONPOSTINDEX */;
   (oper -> val_am3reg).m1 = 0U /* MINUS */;
   (oper -> val_am3reg).m2 = 1U /* LSUNPRIV_LSPREINDEX */;
   (oper -> val_am3reg).m3 = rn;
   (oper -> val_am3reg).m4 = rm;
   return true;
}
static bool tagrulematch_56(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 3U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 3U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =(1U << ra);
   return true;
}
static bool tagrulematch_57(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 5U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 5U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =((1U << ra)+(1U << rb));
   return true;
}
static bool tagrulematch_58(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 7U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 7U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =(((1U << ra)+(1U << rb))+(1U << rc));
   return true;
}
static bool tagrulematch_59(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 9U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 9U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd));
   return true;
}
static bool tagrulematch_60(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 11U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 11U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =(((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re));
   return true;
}
static bool tagrulematch_61(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 13U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 13U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf));
   return true;
}
static bool tagrulematch_62(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 15U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 15U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =(((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg));
   return true;
}
static bool tagrulematch_63(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 17U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 17U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh));
   return true;
}
static bool tagrulematch_64(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 19U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 19U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =(((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri));
   return true;
}
static bool tagrulematch_65(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   uint8_t rj;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 21U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 19U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rj = l__ul;
   l__t = tokenarray_get(toks, 20U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 21U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =((((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri))+(1U << rj));
   return true;
}
static bool tagrulematch_66(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   uint8_t rj;
   uint8_t rk;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 23U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 19U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rj = l__ul;
   l__t = tokenarray_get(toks, 20U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 21U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rk = l__ul;
   l__t = tokenarray_get(toks, 22U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 23U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =(((((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri))+(1U << rj))+(1U << rk));
   return true;
}
static bool tagrulematch_67(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   uint8_t rj;
   uint8_t rk;
   uint8_t rl;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 25U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 19U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rj = l__ul;
   l__t = tokenarray_get(toks, 20U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 21U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rk = l__ul;
   l__t = tokenarray_get(toks, 22U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 23U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rl = l__ul;
   l__t = tokenarray_get(toks, 24U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 25U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =((((((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri))+(1U << rj))+(1U << rk))+(1U << rl));
   return true;
}
static bool tagrulematch_68(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   uint8_t rj;
   uint8_t rk;
   uint8_t rl;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 27U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 19U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rj = l__ul;
   l__t = tokenarray_get(toks, 20U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 21U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rk = l__ul;
   l__t = tokenarray_get(toks, 22U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 23U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rl = l__ul;
   l__t = tokenarray_get(toks, 24U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 25U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 26U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 27U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =(((((((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri))+(1U << rj))+(1U << rk))+(1U << rl))+(1U << rm));
   return true;
}
static bool tagrulematch_69(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   uint8_t rj;
   uint8_t rk;
   uint8_t rl;
   uint8_t rm;
   uint8_t rn;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 29U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 19U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rj = l__ul;
   l__t = tokenarray_get(toks, 20U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 21U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rk = l__ul;
   l__t = tokenarray_get(toks, 22U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 23U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rl = l__ul;
   l__t = tokenarray_get(toks, 24U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 25U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 26U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 27U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 28U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 29U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =((((((((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri))+(1U << rj))+(1U << rk))+(1U << rl))+(1U << rm))+(1U << rn));
   return true;
}
static bool tagrulematch_70(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   uint8_t rj;
   uint8_t rk;
   uint8_t rl;
   uint8_t rm;
   uint8_t rn;
   uint8_t ro;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 31U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 19U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rj = l__ul;
   l__t = tokenarray_get(toks, 20U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 21U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rk = l__ul;
   l__t = tokenarray_get(toks, 22U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 23U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rl = l__ul;
   l__t = tokenarray_get(toks, 24U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 25U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 26U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 27U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 28U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 29U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ro = l__ul;
   l__t = tokenarray_get(toks, 30U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 31U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =(((((((((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri))+(1U << rj))+(1U << rk))+(1U << rl))+(1U << rm))+(1U << rn))+(1U << ro));
   return true;
}
static bool tagrulematch_71(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 4U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 4U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =(1U << ra);
   return true;
}
static bool tagrulematch_72(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 6U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 6U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =((1U << ra)+(1U << rb));
   return true;
}
static bool tagrulematch_73(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 8U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 8U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =(((1U << ra)+(1U << rb))+(1U << rc));
   return true;
}
static bool tagrulematch_74(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 10U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 10U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd));
   return true;
}
static bool tagrulematch_75(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 12U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 12U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =(((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re));
   return true;
}
static bool tagrulematch_76(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 14U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 14U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf));
   return true;
}
static bool tagrulematch_77(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 16U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 16U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =(((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg));
   return true;
}
static bool tagrulematch_78(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 18U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 18U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh));
   return true;
}
static bool tagrulematch_79(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 20U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 19U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 20U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =(((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri));
   return true;
}
static bool tagrulematch_80(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   uint8_t rj;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 22U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 19U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rj = l__ul;
   l__t = tokenarray_get(toks, 20U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 21U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 22U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =((((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri))+(1U << rj));
   return true;
}
static bool tagrulematch_81(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   uint8_t rj;
   uint8_t rk;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 24U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 19U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rj = l__ul;
   l__t = tokenarray_get(toks, 20U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 21U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rk = l__ul;
   l__t = tokenarray_get(toks, 22U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 23U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 24U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =(((((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri))+(1U << rj))+(1U << rk));
   return true;
}
static bool tagrulematch_82(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   uint8_t rj;
   uint8_t rk;
   uint8_t rl;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 26U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 19U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rj = l__ul;
   l__t = tokenarray_get(toks, 20U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 21U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rk = l__ul;
   l__t = tokenarray_get(toks, 22U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 23U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rl = l__ul;
   l__t = tokenarray_get(toks, 24U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 25U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 26U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =((((((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri))+(1U << rj))+(1U << rk))+(1U << rl));
   return true;
}
static bool tagrulematch_83(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   uint8_t rj;
   uint8_t rk;
   uint8_t rl;
   uint8_t rm;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 28U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 19U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rj = l__ul;
   l__t = tokenarray_get(toks, 20U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 21U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rk = l__ul;
   l__t = tokenarray_get(toks, 22U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 23U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rl = l__ul;
   l__t = tokenarray_get(toks, 24U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 25U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 26U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 27U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 28U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =(((((((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri))+(1U << rj))+(1U << rk))+(1U << rl))+(1U << rm));
   return true;
}
static bool tagrulematch_84(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   uint8_t rj;
   uint8_t rk;
   uint8_t rl;
   uint8_t rm;
   uint8_t rn;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 30U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 19U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rj = l__ul;
   l__t = tokenarray_get(toks, 20U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 21U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rk = l__ul;
   l__t = tokenarray_get(toks, 22U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 23U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rl = l__ul;
   l__t = tokenarray_get(toks, 24U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 25U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 26U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 27U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 28U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 29U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 30U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =((((((((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri))+(1U << rj))+(1U << rk))+(1U << rl))+(1U << rm))+(1U << rn));
   return true;
}
static bool tagrulematch_85(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   uint8_t rc;
   uint8_t rd;
   uint8_t re;
   uint8_t rf;
   uint8_t rg;
   uint8_t rh;
   uint8_t ri;
   uint8_t rj;
   uint8_t rk;
   uint8_t rl;
   uint8_t rm;
   uint8_t rn;
   uint8_t ro;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 32U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rc = l__ul;
   l__t = tokenarray_get(toks, 6U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 7U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rd = l__ul;
   l__t = tokenarray_get(toks, 8U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 9U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   re = l__ul;
   l__t = tokenarray_get(toks, 10U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 11U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rf = l__ul;
   l__t = tokenarray_get(toks, 12U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 13U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rg = l__ul;
   l__t = tokenarray_get(toks, 14U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 15U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rh = l__ul;
   l__t = tokenarray_get(toks, 16U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 17U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ri = l__ul;
   l__t = tokenarray_get(toks, 18U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 19U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rj = l__ul;
   l__t = tokenarray_get(toks, 20U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 21U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rk = l__ul;
   l__t = tokenarray_get(toks, 22U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 23U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rl = l__ul;
   l__t = tokenarray_get(toks, 24U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 25U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rm = l__ul;
   l__t = tokenarray_get(toks, 26U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 27U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rn = l__ul;
   l__t = tokenarray_get(toks, 28U);
   if (!((l__t -> t_type)== TOK_COMMA))return false;
   l__t = tokenarray_get(toks, 29U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ro = l__ul;
   l__t = tokenarray_get(toks, 30U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 31U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 32U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =(((((((((((((((1U << ra)+(1U << rb))+(1U << rc))+(1U << rd))+(1U << re))+(1U << rf))+(1U << rg))+(1U << rh))+(1U << ri))+(1U << rj))+(1U << rk))+(1U << rl))+(1U << rm))+(1U << rn))+(1U << ro));
   return true;
}
static bool tagrulematch_86(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 5U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   if (!(l__num == 5U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 0U /* LSM_NORMAL */;
   (oper -> val_reglist).m1 =(uint16_t)(((65535U >> ra)<< ra)&((1U <<(rb + 1U))- 1U));
   return true;
}
static bool tagrulematch_87(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   uint8_t ra;
   uint8_t rb;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 6U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_LBRACE))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   ra = l__ul;
   l__t = tokenarray_get(toks, 2U);
   if (!((l__t -> t_type)== TOK_MINUS))return false;
   l__t = tokenarray_get(toks, 3U);
   if (!(((l__t -> t_type)== TOK_TARGET)&&((l__t -> t_ttype)== TTOK_REG)))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   rb = l__ul;
   l__t = tokenarray_get(toks, 4U);
   if (!((l__t -> t_type)== TOK_RBRACE))return false;
   l__t = tokenarray_get(toks, 5U);
   if (!((l__t -> t_type)== TOK_CARET))return false;
   if (!(l__num == 6U))return false;
   if (!true)return false;
   oper->is_reglist = true;
   (oper -> val_reglist).m0 = 1U /* LSM_PRIV */;
   (oper -> val_reglist).m1 =(uint16_t)(((65535U >> ra)<< ra)&((1U <<(rb + 1U))- 1U));
   return true;
}
static bool tagrulematch_88(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   struct expr * x;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 1U))return false;
   l__x = parserange(lineno, toks, 0U,(l__num - 0U), true);
   if ((l__x == NULL))return false;
   l__x = fold_constant_arithmetic(l__x, true);
   x = l__x;
   if (!is_constant(x))return false;
   oper->is_number = true;
   u_machlarge tmp;
   assert(((x -> x_type)== EXPR_NUM));
   tmp =((x -> x_u). u_num);
   (x -> x_u).u_num = 0;
   expr_destroy(x);
   oper->val_number = tmp;
   return true;
}
static bool tagrulematch_89(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   struct expr * x;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 1U))return false;
   l__x = parserange(lineno, toks, 0U,(l__num - 0U), true);
   if ((l__x == NULL))return false;
   l__x = fold_constant_arithmetic(l__x, true);
   x = l__x;
   if (!true)return false;
   oper->is_expr = true;
   oper->val_expr = x;
   return true;
}
static bool tagrulematch_90(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   struct expr * x;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 1U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_IDENT))return false;
   l__x = parserange(lineno, toks, 0U, 1U, true);
   if ((l__x == NULL))return false;
   l__x = fold_constant_arithmetic(l__x, true);
   x = l__x;
   if (!(l__num == 1U))return false;
   if (!true)return false;
   oper->is_symbol = true;
   oper->val_symbol = x;
   return true;
}
static bool tagrulematch_91(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 1U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_NUMBER))return false;
   errno = 0;
   l__ul = strtoul((l__t -> t_value), &l__end, 0);
   if ((!(errno == 0)|| !(strlen(l__end)== 0)))return false;
   if (!(0 == l__ul))return false;
   if (!(l__num == 1U))return false;
   if (!true)return false;
   oper->is_magiczero = true;
   oper->val_magiczero =(uint32_t)0ULL;
   return true;
}
static bool tagrulematch_92(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   const char * s;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 2U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_PCT))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_IDENT))return false;
   s = dostrdup((l__t -> t_value));
   if (!(l__num == 2U))return false;
   if (!true)return false;
   oper->is_symboltype = true;
   oper->val_symboltype = s;
   return true;
}
static bool tagrulematch_93(int lineno, struct operand * oper, struct tokenarray * toks) {
   unsigned int l__num;
   struct token * l__t;
   struct expr * l__x;
   unsigned long l__ul;
   char * l__end;
   const char * s;
   
   (void)lineno;
   (void)l__t;
   (void)l__x;
   (void)l__ul;
   (void)l__end;
   l__num = tokenarray_num(toks);
   if ((l__num < 2U))return false;
   l__t = tokenarray_get(toks, 0U);
   if (!((l__t -> t_type)== TOK_PCT))return false;
   l__t = tokenarray_get(toks, 1U);
   if (!((l__t -> t_type)== TOK_IDENT))return false;
   s = dostrdup((l__t -> t_value));
   if (!(l__num == 2U))return false;
   if (!true)return false;
   oper->is_sectiontype = true;
   oper->val_sectiontype = s;
   return true;
}
static void opermatch_am2imm(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_22(lineno, oper, toks))return;
   if (tagrulematch_23(lineno, oper, toks))return;
   if (tagrulematch_24(lineno, oper, toks))return;
   if (tagrulematch_25(lineno, oper, toks))return;
   if (tagrulematch_26(lineno, oper, toks))return;
   if (tagrulematch_27(lineno, oper, toks))return;
   if (tagrulematch_28(lineno, oper, toks))return;
}

static void opermatch_am2reg(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_29(lineno, oper, toks))return;
   if (tagrulematch_30(lineno, oper, toks))return;
   if (tagrulematch_31(lineno, oper, toks))return;
   if (tagrulematch_32(lineno, oper, toks))return;
   if (tagrulematch_33(lineno, oper, toks))return;
   if (tagrulematch_34(lineno, oper, toks))return;
   if (tagrulematch_35(lineno, oper, toks))return;
   if (tagrulematch_36(lineno, oper, toks))return;
   if (tagrulematch_37(lineno, oper, toks))return;
   if (tagrulematch_38(lineno, oper, toks))return;
   if (tagrulematch_39(lineno, oper, toks))return;
   if (tagrulematch_40(lineno, oper, toks))return;
}

static void opermatch_am3imm(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_42(lineno, oper, toks))return;
   if (tagrulematch_43(lineno, oper, toks))return;
   if (tagrulematch_44(lineno, oper, toks))return;
   if (tagrulematch_45(lineno, oper, toks))return;
   if (tagrulematch_49(lineno, oper, toks))return;
   if (tagrulematch_50(lineno, oper, toks))return;
   if (tagrulematch_51(lineno, oper, toks))return;
   if (tagrulematch_52(lineno, oper, toks))return;
}

static void opermatch_am3reg(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_46(lineno, oper, toks))return;
   if (tagrulematch_47(lineno, oper, toks))return;
   if (tagrulematch_48(lineno, oper, toks))return;
   if (tagrulematch_53(lineno, oper, toks))return;
   if (tagrulematch_54(lineno, oper, toks))return;
   if (tagrulematch_55(lineno, oper, toks))return;
}

static void opermatch_bangreg(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_5(lineno, oper, toks))return;
   if (tagrulematch_6(lineno, oper, toks))return;
}

static void opermatch_bracketreg(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_41(lineno, oper, toks))return;
}

static void opermatch_expr(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_89(lineno, oper, toks))return;
}

static void opermatch_imm(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_7(lineno, oper, toks))return;
   if (tagrulematch_8(lineno, oper, toks))return;
   if (tagrulematch_9(lineno, oper, toks))return;
   if (tagrulematch_10(lineno, oper, toks))return;
   if (tagrulematch_11(lineno, oper, toks))return;
   if (tagrulematch_12(lineno, oper, toks))return;
}

static void opermatch_ishift(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_19(lineno, oper, toks))return;
   if (tagrulematch_20(lineno, oper, toks))return;
}

static void opermatch_magiczero(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_91(lineno, oper, toks))return;
}

static void opermatch_number(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_88(lineno, oper, toks))return;
}

static void opermatch_qstring(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_0(lineno, oper, toks))return;
}

static void opermatch_reg(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_1(lineno, oper, toks))return;
}

static void opermatch_reglist(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_56(lineno, oper, toks))return;
   if (tagrulematch_57(lineno, oper, toks))return;
   if (tagrulematch_58(lineno, oper, toks))return;
   if (tagrulematch_59(lineno, oper, toks))return;
   if (tagrulematch_60(lineno, oper, toks))return;
   if (tagrulematch_61(lineno, oper, toks))return;
   if (tagrulematch_62(lineno, oper, toks))return;
   if (tagrulematch_63(lineno, oper, toks))return;
   if (tagrulematch_64(lineno, oper, toks))return;
   if (tagrulematch_65(lineno, oper, toks))return;
   if (tagrulematch_66(lineno, oper, toks))return;
   if (tagrulematch_67(lineno, oper, toks))return;
   if (tagrulematch_68(lineno, oper, toks))return;
   if (tagrulematch_69(lineno, oper, toks))return;
   if (tagrulematch_70(lineno, oper, toks))return;
   if (tagrulematch_71(lineno, oper, toks))return;
   if (tagrulematch_72(lineno, oper, toks))return;
   if (tagrulematch_73(lineno, oper, toks))return;
   if (tagrulematch_74(lineno, oper, toks))return;
   if (tagrulematch_75(lineno, oper, toks))return;
   if (tagrulematch_76(lineno, oper, toks))return;
   if (tagrulematch_77(lineno, oper, toks))return;
   if (tagrulematch_78(lineno, oper, toks))return;
   if (tagrulematch_79(lineno, oper, toks))return;
   if (tagrulematch_80(lineno, oper, toks))return;
   if (tagrulematch_81(lineno, oper, toks))return;
   if (tagrulematch_82(lineno, oper, toks))return;
   if (tagrulematch_83(lineno, oper, toks))return;
   if (tagrulematch_84(lineno, oper, toks))return;
   if (tagrulematch_85(lineno, oper, toks))return;
   if (tagrulematch_86(lineno, oper, toks))return;
   if (tagrulematch_87(lineno, oper, toks))return;
}

static void opermatch_rshift(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_21(lineno, oper, toks))return;
}

static void opermatch_rtag(int lineno, struct operand * oper, struct tokenarray * toks) {
   (void)lineno;
   (void)oper;
   (void)toks;
}

static void opermatch_sectiontype(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_93(lineno, oper, toks))return;
}

static void opermatch_signedimm12(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_16(lineno, oper, toks))return;
   if (tagrulematch_17(lineno, oper, toks))return;
   if (tagrulematch_18(lineno, oper, toks))return;
}

static void opermatch_signedimm8(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_13(lineno, oper, toks))return;
   if (tagrulematch_14(lineno, oper, toks))return;
   if (tagrulematch_15(lineno, oper, toks))return;
}

static void opermatch_signedreg(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_2(lineno, oper, toks))return;
   if (tagrulematch_3(lineno, oper, toks))return;
   if (tagrulematch_4(lineno, oper, toks))return;
}

static void opermatch_symbol(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_90(lineno, oper, toks))return;
}

static void opermatch_symboltype(int lineno, struct operand * oper, struct tokenarray * toks) {
   if (tagrulematch_92(lineno, oper, toks))return;
}

void operand_init(struct operand * oper) {
   oper->is_am2imm = false;
   (oper -> val_am2imm).m0 = 0U;
   (oper -> val_am2imm).m1 = 0U;
   (oper -> val_am2imm).m2 = 0U;
   (oper -> val_am2imm).m3 = 0U;
   (oper -> val_am2imm).m4 = 0U;
   oper->is_am2reg = false;
   (oper -> val_am2reg).m0 = 0U;
   (oper -> val_am2reg).m1 = 0U;
   (oper -> val_am2reg).m2 = 0U;
   (oper -> val_am2reg).m3 = 0U;
   (oper -> val_am2reg).m4 = 0U;
   (oper -> val_am2reg).m5 = 0U;
   (oper -> val_am2reg).m6 = 0U;
   oper->is_am3imm = false;
   (oper -> val_am3imm).m0 = 0U;
   (oper -> val_am3imm).m1 = 0U;
   (oper -> val_am3imm).m2 = 0U;
   (oper -> val_am3imm).m3 = 0U;
   (oper -> val_am3imm).m4 = 0U;
   oper->is_am3reg = false;
   (oper -> val_am3reg).m0 = 0U;
   (oper -> val_am3reg).m1 = 0U;
   (oper -> val_am3reg).m2 = 0U;
   (oper -> val_am3reg).m3 = 0U;
   (oper -> val_am3reg).m4 = 0U;
   oper->is_bangreg = false;
   (oper -> val_bangreg).m0 = 0U;
   (oper -> val_bangreg).m1 = 0U;
   oper->is_bracketreg = false;
   oper->val_bracketreg = 0U;
   oper->is_expr = false;
   oper->val_expr = NULL;
   oper->is_imm = false;
   oper->val_imm = 0U;
   oper->is_ishift = false;
   (oper -> val_ishift).m0 = 0U;
   (oper -> val_ishift).m1 = 0U;
   oper->is_magiczero = false;
   oper->val_magiczero = 0U;
   oper->is_number = false;
   oper->val_number = 0U;
   oper->is_qstring = false;
   oper->val_qstring = NULL;
   oper->is_reg = false;
   oper->val_reg = 0U;
   oper->is_reglist = false;
   (oper -> val_reglist).m0 = 0U;
   (oper -> val_reglist).m1 = 0U;
   oper->is_rshift = false;
   (oper -> val_rshift).m0 = 0U;
   (oper -> val_rshift).m1 = 0U;
   oper->is_rtag = false;
   oper->val_rtag = 0U;
   oper->is_sectiontype = false;
   oper->val_sectiontype = NULL;
   oper->is_signedimm12 = false;
   (oper -> val_signedimm12).m0 = 0U;
   (oper -> val_signedimm12).m1 = 0U;
   oper->is_signedimm8 = false;
   (oper -> val_signedimm8).m0 = 0U;
   (oper -> val_signedimm8).m1 = 0U;
   oper->is_signedreg = false;
   (oper -> val_signedreg).m0 = 0U;
   (oper -> val_signedreg).m1 = 0U;
   oper->is_symbol = false;
   oper->val_symbol = NULL;
   oper->is_symboltype = false;
   oper->val_symboltype = NULL;
}
void operand_cleanup(struct operand * oper) {
   (void)oper;
   expr_destroy((oper -> val_expr));
   expr_destroy((oper -> val_symbol));
}
void operand_match(int lineno, struct operand * oper, struct tokenarray * toks) {
   opermatch_am2imm(lineno, oper, toks);
   opermatch_am2reg(lineno, oper, toks);
   opermatch_am3imm(lineno, oper, toks);
   opermatch_am3reg(lineno, oper, toks);
   opermatch_bangreg(lineno, oper, toks);
   opermatch_bracketreg(lineno, oper, toks);
   opermatch_expr(lineno, oper, toks);
   opermatch_imm(lineno, oper, toks);
   opermatch_ishift(lineno, oper, toks);
   opermatch_magiczero(lineno, oper, toks);
   opermatch_number(lineno, oper, toks);
   opermatch_qstring(lineno, oper, toks);
   opermatch_reg(lineno, oper, toks);
   opermatch_reglist(lineno, oper, toks);
   opermatch_rshift(lineno, oper, toks);
   opermatch_rtag(lineno, oper, toks);
   opermatch_sectiontype(lineno, oper, toks);
   opermatch_signedimm12(lineno, oper, toks);
   opermatch_signedimm8(lineno, oper, toks);
   opermatch_signedreg(lineno, oper, toks);
   opermatch_symbol(lineno, oper, toks);
   opermatch_symboltype(lineno, oper, toks);
}
